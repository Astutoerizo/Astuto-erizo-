<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>Astuto Erizo - Respira y Grita</title>
  <style>
    html,body{margin:0;height:100%;background:#0e0e10;color:#fff;font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif}
    #wrap{position:fixed;inset:0;display:flex;align-items:center;justify-content:center}
    canvas{background:#1b1b1f;touch-action:none;display:block}
    .hud{position:fixed;top:8px;left:50%;transform:translateX(-50%);width:min(92vw,540px);pointer-events:none;display:flex;align-items:center;gap:12px;justify-content:space-between;font-weight:600}
    .bar{flex:1;height:14px;background:#3a3a44;border-radius:999px;overflow:hidden;border:2px solid #6ee7b7;box-shadow:0 0 6px rgba(110,231,183,0.6) inset}
    .fill{height:100%;width:0%;background:#86efac;transition:width .08s linear}
    .cooldown{opacity:.45}
    .score{min-width:100px;text-align:right}
    .hud-btn{pointer-events:auto;cursor:pointer;padding:4px 8px;background:#24242a;border-radius:6px;font-size:13px}
    .toast{position:fixed;bottom:14px;left:50%;transform:translateX(-50%);background:#24242a;border:1px solid #333;padding:8px 12px;border-radius:10px;font-size:14px;opacity:.95}
    .panel{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);transition:opacity .2s ease}
    .panel.show{display:flex;opacity:1;pointer-events:auto}
    .card{background:#1e1e24;border:1px solid #333;border-radius:16px;padding:20px;width:min(92vw,420px);text-align:center;box-shadow:0 10px 30px rgba(0,0,0,.35)}
    .btn{display:inline-block;margin-top:12px;padding:10px 16px;border-radius:12px;background:#6ee7b7;color:#0b0b0d;font-weight:700;cursor:pointer;user-select:none}
    /* Countdown */
    #countdown{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);backdrop-filter:blur(2px);z-index:999}
    #countdown.show{display:flex}
    #countdown #countNum{font-size:clamp(64px,20vw,220px);font-weight:900;letter-spacing:-0.03em;color:#fff;text-shadow:0 6px 24px rgba(0,0,0,.6)}
    #countdown img{max-width:60%;height:auto;display:block;margin:0 auto;animation:zoomIn .6s ease}
    @keyframes zoomIn{from{transform:scale(.5);opacity:0}to{transform:scale(1);opacity:1}}
    /* Loader */
    #loader{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;background:#0e0e10;z-index:2000}
    #loader img{max-width:220px;animation:float 1.8s ease-in-out infinite}
    #loader p{margin-top:12px;font-size:18px;color:#6ee7b7;font-weight:700;animation:blink 1.2s infinite}
    @keyframes float{0%,100%{transform:translateY(0)}50%{transform:translateY(-12px)}}
    @keyframes blink{0%,100%{opacity:1}50%{opacity:.4}}
    /* small adjustments */
    .small-muted{opacity:.75;font-size:13px}
  </style>
</head>
<body>
  <!-- LOADER -->
  <div id="loader">
    <img id="loaderImg" src="assets/loader.png" alt="Cargando...">
    <p>Loading...</p>
  </div>

  <!-- CANVAS -->
  <div id="wrap"><canvas id="game" width="540" height="960"></canvas></div>

  <!-- HUD -->
  <div class="hud">
    <div class="bar" title="Nivel de respiraciÃ³n (Zen)"><div class="fill" id="zenFill"></div></div>
    <div class="score" id="score">Puntos: 0</div>
    <div class="score" id="bestScore">Mejor: 0</div>
    <div class="hud-btn" id="btnMusic">ðŸ”Š</div>
  </div>

  <!-- Hint -->
  <div class="toast" id="hint">MantÃ©n pulsado para inhalar Â· Suelta para gritar</div>

  <!-- GAME OVER PANEL -->
  <div class="panel" id="panel">
    <div class="card">
      <h2>Astuto Erizo</h2>
      <p id="panelMsg">Has gritado al vacÃ­o zenâ€¦</p>
      <div class="btn" id="btnRestart">Reintentar</div>
      <p class="small-muted" style="margin-top:8px">MantÃ©n pulsado para inhalar Â· Suelta para gritar</p>
    </div>
  </div>

  <!-- MENU PANEL -->
  <div class="panel show" id="menuPanel">
    <div class="card">
      <img src="assets/logo_videojuego.png" alt="Astuto Erizo" style="max-width:260px;margin-bottom:12px">
      <h2>Respira y Grita</h2>
      <p id="menuBest" class="small-muted">Mejor puntuaciÃ³n: 0</p>
      <p>Cuando estÃ©s listo, pulsa jugar y respira profundoâ€¦</p>
      <div class="btn" id="btnStart">Jugar</div>
      <p class="small-muted" style="margin-top:10px">MantÃ©n pulsado para inhalar Â· Suelta para gritar</p>
    </div>
  </div>

  <!-- COUNTDOWN -->
  <div id="countdown"><div id="countNum"></div></div>

  <script>
  (function(){
    // ================= CONFIG & FLAGS =================
    const TEST_MODE = true; // <<-- mantener true durante test; cambiar a false para producciÃ³n
    // Umbrales (si TEST_MODE=true, usar valores bajos para pruebas rÃ¡pidas)
    const THRESHOLDS = {
      bg1: TEST_MODE ? 5 : 50,
      bg2: TEST_MODE ? 8 : 85
    };

    // Mundo y fÃ­sicas
    const WORLD = { w: 540, h: 960 };
    const GROUND_H = 180;
    const SPEED = { scroll: 280, inc: 20, max: 520 };
    const SPAWN = { interval: 1.2, min: 0.7, timer: 0, diffTimer: 0 };
    const PHYSICS = { gravity: 600, inhaleForce: -1400, maxVy: 700 }; // inhaleForce aumentado para respuesta mÃ¡s rÃ¡pida

    const CHARGE = { value: 0, rate: 120, max: 100, over: 85, cooldown: 0, cooldownBase: 1.0 }; // rate aumentado para inflado mÃ¡s rÃ¡pido
    const PULSE = { base: 120, max: 380, life: 0.25 };
    const POINTS = { total: 0, best: parseInt(localStorage.getItem("bestScore")||"0",10) || 0 };

    // ================= DOM / CANVAS =================
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const zenFill = document.getElementById('zenFill');
    const scoreEl = document.getElementById('score');
    const bestScoreEl = document.getElementById('bestScore');
    const menuBestEl = document.getElementById('menuBest');
    const panel = document.getElementById('panel');
    const panelMsg = document.getElementById('panelMsg');
    const btnRestart = document.getElementById('btnRestart');
    const hint = document.getElementById('hint');
    const menuPanel = document.getElementById('menuPanel');
    const btnStart = document.getElementById('btnStart');
    const countdownEl = document.getElementById('countdown');
    const countNum = document.getElementById('countNum');
    const loader = document.getElementById('loader');
    const loaderImg = document.getElementById('loaderImg');
    const btnMusic = document.getElementById('btnMusic');

    // Fit canvas to viewport (maintain pixel size via CSS)
    let scale=1, offsetX=0, offsetY=0;
    function fit(){
      const vw = window.innerWidth, vh = window.innerHeight;
      const s = Math.min(vw / WORLD.w, vh / WORLD.h);
      scale = s; offsetX = (vw - WORLD.w * s)/2; offsetY = (vh - WORLD.h * s)/2;
      canvas.style.width = WORLD.w*s + 'px';
      canvas.style.height = WORLD.h*s + 'px';
    }
    window.addEventListener('resize', fit);
    fit();

    // ================= INPUT =================
    let isDown = false, justReleased = false, wasInhaling = false;
    let inhaleSfxTimer = 0;
    function withinCanvas(clientX, clientY){
      const x = (clientX - offsetX) / scale, y = (clientY - offsetY) / scale;
      return x>=0 && x<=WORLD.w && y>=0 && y<=WORLD.h;
    }
    canvas.addEventListener('pointerdown', async (e)=>{
      if (!withinCanvas(e.clientX,e.clientY)) return;
      isDown = true; e.preventDefault(); hint.style.display='none';
      // resume audio context if needed (some browsers require user gesture)
      try { if (audioCtx && audioCtx.state === 'suspended') await audioCtx.resume(); } catch(e){}
    });
    window.addEventListener('pointerup', (e)=>{
      if (!isDown) return;
      isDown = false; justReleased = true; e.preventDefault();
    });

    // ================= AUDIO =================
    // Usamos simple Audio() para compatibilidad. music handled separately.
    const audioCtx = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;

    const SFX_FILES = {
      grito: "assets/sonido_bowl_limpio.mp3",
      recolectar: "assets/sonido_recolectar_platano.mp3",
      inhalar: "assets/sonido_inhalar.mp3",
      chocar: "assets/sonido_chocar.mp3",
      woosh: "assets/woosh.mp3",
      gong: "assets/gong.mp3"
    };
    const SFX_VOL = { grito:0.35, recolectar:0.6, inhalar:0.25, chocar:0.6, woosh:0.75, gong:0.7 };

    function playSfx(name, vol){
      const src = SFX_FILES[name];
      if (!src) return;
      const a = new Audio(src);
      a.volume = (typeof vol === 'number') ? vol : (SFX_VOL[name] || 1.0);
      // prevent play after gameover by checking state
      if (gameOver) return;
      a.play().catch(()=>{});
      return a;
    }

    // MUSIC (loop)
    const MUSIC = {
      base: new Audio("assets/musica_base.mp3"),
      bonus: new Audio("assets/musica_bonus.mp3"),
      boss: new Audio("assets/musica_boss.mp3")
    };
    Object.values(MUSIC).forEach(a=>{ a.loop=true; a.volume=0.45; a.preload='auto'; });

    let musicEnabled = true;
    let currentMusic = MUSIC.base;
    function playMusic(track){
      if (!musicEnabled) return;
      try{
        if (currentMusic && !currentMusic.paused) currentMusic.pause();
        currentMusic = track || MUSIC.base;
        currentMusic.currentTime = 0;
        currentMusic.play().catch(()=>{});
      }catch(e){}
    }
    function stopAllMusic(){
      try{ Object.values(MUSIC).forEach(a=>{ try{ a.pause(); a.currentTime=0; } catch(e){} }); } catch(e){}
    }
    btnMusic.addEventListener('click', ()=>{
      musicEnabled = !musicEnabled;
      if (musicEnabled){ playMusic(currentMusic); btnMusic.textContent = "ðŸ”Š"; }
      else { stopAllMusic(); btnMusic.textContent = "ðŸ”‡"; }
    });

    // ================= ASSETS =================
    const ASSETS = {
      bg: { calc: "assets/fondo_calc.png", desierto: "assets/fondo_desierto.png", helado: "assets/fondo_helado.png" },
      erizo: { calmado: "assets/calmado.png", inhalando: "assets/respirando.png", gritando: "assets/gritando.png", parpadeo: "assets/erizo_parpadeo.png" },
      obstaculos: ["assets/paraguas.png","assets/helado_meditando.png"],
      banana: "assets/platano_puntos.png",
      cuenco: "assets/cuenco_tibetano.png",
      suelo: "assets/suelo.png",
      nubes: ["assets/nubes/nube1.png","assets/nubes/nube2.png","assets/nubes/nube3.png","assets/nubes/nube4.png"],
      contador: ["assets/contador_arbol.png","assets/contador_calcetin.png","assets/contador_leche.png","assets/contador_cuenco.png","assets/contador_antena.png","assets/contador_seta.png","assets/contador_coche.png","assets/contador_lapiz.png","assets/contador_paraguas.png","assets/contador_helado.png"],
      contadorGo: "assets/contador_go.png",
      loaders: ["assets/loader.png","assets/loader1.png","assets/loader2.png","assets/loader3.png"]
    };

    const IMG = { bg:{}, erizo:{}, obstaculos:[], banana:null, cuenco:null, suelo:null, nubes:[], contador:[], contadorGo:null };

    function loadImage(src){ return new Promise(res=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=()=>{ console.warn("img error", src); res(null); }; i.src = src; }); }

    async function loadAll(){
      // fondos
      IMG.bg.calc = await loadImage(ASSETS.bg.calc);
      IMG.bg.desierto = await loadImage(ASSETS.bg.desierto);
      IMG.bg.helado = await loadImage(ASSETS.bg.helado);
      // erizo
      IMG.erizo.calmado = await loadImage(ASSETS.erizo.calmado);
      IMG.erizo.inhalando = await loadImage(ASSETS.erizo.inhalando);
      IMG.erizo.gritando = await loadImage(ASSETS.erizo.gritando);
      IMG.erizo.parpadeo = await loadImage(ASSETS.erizo.parpadeo);
      // obstaculos
      for (let s of ASSETS.obstaculos) IMG.obstaculos.push(await loadImage(s));
      IMG.banana = await loadImage(ASSETS.banana);
      IMG.cuenco = await loadImage(ASSETS.cuenco);
      IMG.suelo = await loadImage(ASSETS.suelo);
      for (let s of ASSETS.nubes) IMG.nubes.push(await loadImage(s));
      for (let s of ASSETS.contador) IMG.contador.push(await loadImage(s));
      IMG.contadorGo = await loadImage(ASSETS.contadorGo);
    }

    // ================= ENTITIES =================
    const player = { x: 140, y: WORLD.h - GROUND_H - 40, r: 40, vy: 0, state: 'calmado', mareo: 0 };
    const sueloScroll = [ { x:0 }, { x: WORLD.w } ];
    const obstacles = [], bananas = [], pulses = [], particles = [];
    const CLOUD = { list: [] };

    // ================= UTIL =================
    const rand = (a,b) => a + Math.random()*(b-a);
    const chance = p => Math.random() < p;
    function dist2(ax,ay,bx,by){ const dx=ax-bx, dy=ay-by; return dx*dx + dy*dy; }

    // ================= CLOUDS =================
    function initClouds(){
      CLOUD.list = [];
      for (let i=0;i<10;i++){
        const band = Math.floor(rand(0,3));
        const img = IMG.nubes.length ? IMG.nubes[Math.floor(rand(0, IMG.nubes.length))] : null;
        CLOUD.list.push({ x: rand(0, WORLD.w), y: rand(40, WORLD.h/2), w: rand(80,180), h: rand(50,100), speed: 20 + band*40, band, img });
      }
    }

    // ================= RESET / GAMEOVER =================
    let bgStage = 0;
    let currentBg = null;
    let gameOver = false;
    function resetGame(){
      POINTS.total = 0;
      CHARGE.value = 0;
      CHARGE.cooldown = 0;
      SPEED.scroll = 280;
      SPAWN.interval = 1.2; SPAWN.timer = 0; SPAWN.diffTimer = 0;
      obstacles.length = 0; bananas.length = 0; pulses.length = 0; particles.length = 0;
      player.y = WORLD.h - GROUND_H - player.r + 20;
      player.vy = 0; player.state = 'calmado'; player.mareo = 0;
      bgStage = 0; currentBg = IMG.bg.calc;
      panel.classList.remove('show');
      hint.style.display = '';
      initClouds();
      gameOver = false;
      // restart music if enabled
      if (musicEnabled) playMusic(MUSIC.base);
    }

    function onGameOver(msg){
      gameOver = true;
      panelMsg.textContent = msg || "Has gritado al vacÃ­o zenâ€¦";
      panel.classList.add('show');
      // stop spawning/loop; stop all sfx and music
      stopAllMusic();
      // No further sfx should play â€” we guard plays by checking gameOver
      // but also we can silence current audio elements by pausing them (we attempted above)
    }

    btnRestart.addEventListener('click', ()=>{
      // small delay to give player time (as requested)
      panel.classList.remove('show');
      setTimeout(()=>{
        resetGame();
        lastFrame = performance.now();
        requestAnimationFrame(loop);
      }, 500);
    });

    // ================= SPAWNING =================
    function spawnObstacle(){
      const y = rand(240, WORLD.h - 180);
      const r = rand(44, 70);
      const speed = Math.min(SPEED.scroll + rand(0,60), SPEED.max);
      obstacles.push({ x: WORLD.w + 60, y, r, speed, kind: Math.floor(rand(0, IMG.obstaculos.length)) });
      if (chance(0.3)) bananas.push({ x: WORLD.w + 100, y: rand(220, WORLD.h-200), r: 36, speed: speed + 40, kind: 'banana' });
      if (chance(0.1)) bananas.push({ x: WORLD.w + 150, y: rand(220, WORLD.h-200), r: 36, speed: speed + 20, kind: 'cuenco' });
    }

    // ================= UPDATE =================
    function update(dt){
      if (gameOver) return;

      // fondo por puntos
      if (POINTS.total >= THRESHOLDS.bg2 && bgStage < 2){
        setTimeout(()=>playSfx('woosh'), 120);
        currentBg = IMG.bg.helado; bgStage = 2;
      } else if (POINTS.total >= THRESHOLDS.bg1 && bgStage < 1){
        setTimeout(()=>playSfx('woosh'), 120);
        currentBg = IMG.bg.desierto; bgStage = 1;
      }

      // suelo scroll
      for (let s of sueloScroll){ s.x -= SPEED.scroll * dt; if (s.x <= -WORLD.w) s.x += WORLD.w * 2; }

      // clouds move
      for (const c of CLOUD.list){
        c.x -= c.speed * dt;
        if (c.x + c.w < 0){
          c.x = WORLD.w + rand(10,100);
          c.y = rand(50,WORLD.h/2);
          c.w = rand(80,180);
          c.h = rand(50,100);
          c.img = IMG.nubes.length ? IMG.nubes[Math.floor(rand(0,IMG.nubes.length))] : null;
        }
      }

      // spawn logic
      SPAWN.timer += dt;
      SPAWN.diffTimer += dt;
      if (SPAWN.timer >= SPAWN.interval) { SPAWN.timer = 0; spawnObstacle(); }
      if (SPAWN.diffTimer >= 10){ SPAWN.diffTimer = 0; SPEED.scroll = Math.min(SPEED.scroll + SPEED.inc, SPEED.max); SPAWN.interval = Math.max(SPAWN.min, SPAWN.interval - 0.05); }

      // input & charge (inhale)
      if (isDown && CHARGE.cooldown <= 0){
        player.state = 'inhalando';
        // make inhalation immediate and stronger: apply impulse when starting inhale
        if (!wasInhaling) {
          // small upward impulse improves responsiveness
          player.vy += PHYSICS.inhaleForce * 0.02;
          playSfx('inhalar', 0.25);
          inhaleSfxTimer = 0;
        } else {
          inhaleSfxTimer += dt;
          if (inhaleSfxTimer >= 0.5) { playSfx('inhalar', 0.25); inhaleSfxTimer = 0; }
        }
        // continuous inhale effect
        const boost = (player.vy > 0 ? 1.5 : 1.0);
        player.vy += PHYSICS.inhaleForce * boost * dt;
        CHARGE.value = Math.min(CHARGE.max, CHARGE.value + CHARGE.rate * dt);
      }
      wasInhaling = isDown && CHARGE.cooldown <= 0;

      // gravity and vertical movement
      player.vy += PHYSICS.gravity * dt;
      if (player.vy > PHYSICS.maxVy) player.vy = PHYSICS.maxVy;
      player.y += player.vy * dt;

      // limit top (do not allow to disappear)
      const topLimit = 80; // min y
      if (player.y < topLimit){ player.y = topLimit; player.vy = Math.max(0, player.vy); }

      // ground collision
      const sueloTop = WORLD.h - GROUND_H - player.r;
      if (player.y > sueloTop){ player.y = sueloTop; player.vy = 0; }

      // release -> pulse / big shout
      if (justReleased){
        justReleased = false;
        if (CHARGE.cooldown <= 0){
          if (CHARGE.value >= CHARGE.over){
            // powerful shout/overcharged
            CHARGE.cooldown = 0.7; CHARGE.value = 0;
            player.state = 'gritando';
            // we do not auto-destroy obstacles; strong shout could be special (left as future)
            playSfx('grito', SFX_VOL.grito);
          } else {
            const t = CHARGE.value / CHARGE.max;
            const rad = PULSE.base + t*(PULSE.max - PULSE.base);
            pulses.push({ x: player.x + 40, y: player.y, rad, life: PULSE.life });
            CHARGE.cooldown = CHARGE.cooldownBase;
            CHARGE.value = 0;
            player.state = 'gritando';
            playSfx('grito', SFX_VOL.grito);
          }
        }
        inhaleSfxTimer = 0;
      }

      // cooldown
      if (CHARGE.cooldown > 0) { CHARGE.cooldown -= dt; if (CHARGE.cooldown < 0) CHARGE.cooldown = 0; }

      // simple state fallback
      if (!isDown && CHARGE.cooldown === 0 && player.state !== 'mareado') player.state = 'calmado';

      // particles
      if (Math.random() < 0.12) {
        particles.push({ x: player.x + rand(-20,20), y: player.y + rand(-20,20), vx: rand(-15,15), vy: rand(-30,-10), life: 1.0, color: `rgba(255,${200+Math.floor(55*Math.random())},255,` });
      }
      for (let i = particles.length-1; i>=0; i--){
        const p = particles[i];
        p.x += p.vx * dt; p.y += p.vy * dt; p.life -= dt * 0.5; if (p.life <= 0) particles.splice(i,1);
      }

      // pulses affect obstacles (destroy)
      for (let i = pulses.length-1; i>=0; i--){
        const p = pulses[i]; p.life -= dt;
        if (p.life <= 0){ pulses.splice(i,1); continue; }
        for (let j = obstacles.length-1; j>=0; j--){
          const o = obstacles[j];
          if (dist2(p.x,p.y,o.x,o.y) <= (p.rad + o.r)*(p.rad + o.r)){
            obstacles.splice(j,1);
            POINTS.total += 2; // reward for destroying
            // NO collect sfx here (only on bananas/cuencos)
          }
        }
      }

      // move obstacles & bananas
      for (let i = obstacles.length-1; i>=0; i--){
        const o = obstacles[i];
        o.x -= o.speed * dt;
        if (o.x < -120) obstacles.splice(i,1);
      }
      for (let i = bananas.length-1; i>=0; i--){
        const b = bananas[i];
        b.x -= b.speed * dt;
        if (b.x < -120) bananas.splice(i,1);
      }

      // collisions with obstacles -> game over
      for (let i = obstacles.length-1; i>=0; i--){
        const o = obstacles[i];
        if (dist2(o.x,o.y,player.x,player.y) <= (o.r + player.r)*(o.r + player.r)){
          // collision - game over
          playSfx('chocar', SFX_VOL.chocar);
          onGameOver( randomCrashMessage() );
          return; // exit update to avoid further state changes
        }
      }

      // collision with bananas/cuencos -> collect
      for (let i = bananas.length-1; i>=0; i--){
        const b = bananas[i];
        if (dist2(b.x,b.y,player.x,player.y) <= (b.r + player.r)*(b.r + player.r)){
          bananas.splice(i,1);
          const pts = (b.kind === 'cuenco') ? 5 : 1;
          POINTS.total += pts;
          playSfx('recolectar', 0.6);
        }
      }

      // HUD
      scoreEl.textContent = "Puntos: " + POINTS.total;
      zenFill.style.width = (CHARGE.value / CHARGE.max) * 100 + "%";
      zenFill.parentElement.classList.toggle('cooldown', CHARGE.cooldown > 0);
    } // update

    // some fun crash messages (as before)
    function randomCrashMessage(){
      const CRASH = [
        "El erizo se quedÃ³ sin aireâ€¦ como tus plantas en agosto.",
        "Has gritado al vacÃ­o. El vacÃ­o gritÃ³ de vuelta.",
        "Chocaste contra la iluminaciÃ³nâ€¦ pero era un helado.",
        "Tu zen se fue por el paraguas roto.",
        "El universo respondiÃ³ con un plÃ¡tano invisible.",
        "Erizo y obstÃ¡culo se fundieron en un abrazo incÃ³modo.",
        "La serenidad se tropezÃ³ contigo.",
        "Has visto la luz... y duele.",
        "Un pato de goma presenciÃ³ tu derrota."
      ];
      return CRASH[Math.floor(Math.random()*CRASH.length)];
    }

    // ================= DRAW =================
    function draw(){
      // clear
      ctx.clearRect(0,0,WORLD.w,WORLD.h);

      // background
      if (currentBg) ctx.drawImage(currentBg, 0, 0, WORLD.w, WORLD.h);
      else { ctx.fillStyle = '#1b1b1f'; ctx.fillRect(0,0,WORLD.w,WORLD.h); }

      // if gameOver, draw only background (as requested)
      if (gameOver){
        // optionally draw a subtle overlay behind the panel
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(0,0,WORLD.w,WORLD.h);
        return;
      }

      // clouds (layered by band)
      for (let pass=0; pass<3; pass++){
        for (const c of CLOUD.list){
          if (c.band !== pass) continue;
          if (c.img) ctx.drawImage(c.img, c.x, c.y, c.w, c.h);
          else { ctx.fillStyle = 'rgba(255,255,255,0.85)'; ctx.beginPath(); ctx.ellipse(c.x + c.w/2, c.y + c.h/2, c.w/2, c.h/3, 0, 0, Math.PI*2); ctx.fill(); }
        }
      }

      // bananas / cuencos
      for (const b of bananas){
        if (b.kind === 'cuenco' && IMG.cuenco) ctx.drawImage(IMG.cuenco, b.x - b.r, b.y - b.r, b.r*2, b.r*2);
        else if (IMG.banana) ctx.drawImage(IMG.banana, b.x - b.r, b.y - b.r, b.r*2, b.r*2);
      }

      // obstacles
      for (const o of obstacles){
        const img = IMG.obstaculos[o.kind] || null;
        if (img) ctx.drawImage(img, o.x - o.r, o.y - o.r, o.r*2, o.r*2);
        else { ctx.fillStyle = '#ef4444'; ctx.beginPath(); ctx.arc(o.x,o.y,o.r,0,Math.PI*2); ctx.fill(); }
      }

      // pulses (circle)
      for (const p of pulses){
        const alpha = Math.max(0, p.life / PULSE.life);
        ctx.strokeStyle = `rgba(99,102,241,${alpha})`;
        ctx.lineWidth = 6;
        ctx.beginPath(); ctx.arc(p.x, p.y, p.rad, 0, Math.PI*2); ctx.stroke();
      }

      // suelo
      for (let s of sueloScroll){
        if (IMG.suelo) ctx.drawImage(IMG.suelo, s.x, WORLD.h - GROUND_H, WORLD.w, GROUND_H);
        else { ctx.fillStyle = '#4ade80'; ctx.fillRect(s.x, WORLD.h - GROUND_H, WORLD.w, GROUND_H); }
      }

      // particles
      for (const p of particles){
        const alpha = Math.max(0, p.life);
        ctx.fillStyle = p.color + alpha + ")";
        ctx.beginPath(); ctx.arc(p.x, p.y, 3, 0, Math.PI*2); ctx.fill();
      }

      // aura around player
      const pulse = 0.6 + 0.2 * Math.sin(performance.now() / 300);
      ctx.fillStyle = `rgba(255,255,255,${0.25 * pulse})`;
      ctx.beginPath(); ctx.arc(player.x, player.y, 60, 0, Math.PI*2); ctx.fill();

      // erizo sprite: choose appropriate image; fallback to calmado
      let erizoImg = IMG.erizo.calmado;
      if (player.state === 'inhalando' && IMG.erizo.inhalando) erizoImg = IMG.erizo.inhalando;
      if (player.state === 'gritando' && IMG.erizo.gritando) erizoImg = IMG.erizo.gritando;
      // small random blink: if we have parpadeo sprite, randomly show during draw to simulate blink (non-essential)
      if (IMG.erizo.parpadeo && Math.random() < 0.01) erizoImg = IMG.erizo.parpadeo;

      if (erizoImg){
        const w = player.r*2, h = player.r*2;
        ctx.drawImage(erizoImg, player.x - player.r, player.y - player.r, w, h);
      } else {
        // fallback circle
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(player.x, player.y, player.r, 0, Math.PI*2); ctx.fill();
      }

    } // draw

    // ================= LOOP =================
    let lastFrame = performance.now();
    function loop(ts){
      const now = ts || performance.now();
      const dt = Math.min(0.033, (now - lastFrame) / 1000);
      lastFrame = now;
      update(dt);
      draw();
      if (!gameOver) requestAnimationFrame(loop);
    }

    // ================= COUNTDOWN UI =================
    function showCountdown(onDone){
      // choose 3 random images + GO
      let pool = ASSETS.contador.slice(); // paths
      let seq = [];
      // if images not available, fallback to numbers text
      for (let i=0;i<3;i++){
        if (pool.length === 0) break;
        const idx = Math.floor(Math.random()*pool.length);
        seq.push(pool.splice(idx,1)[0]);
      }
      seq.push(ASSETS.contadorGo);
      let i = 0;
      countdownEl.classList.add('show');
      function next(){
        if (i < seq.length){
          const src = seq[i++];
          // try to show image; if missing, show numeric fallback
          countNum.innerHTML = `<img src="${src}" alt="count">`;
          // play gong
          playSfx('gong', 0.7);
          setTimeout(next, 900);
        } else {
          countdownEl.classList.remove('show');
          if (typeof onDone === 'function') onDone();
        }
      }
      next();
    }

    // ================= START / MENU =================
    function updateBestDisplays(){
      bestScoreEl.textContent = "Mejor: " + POINTS.best;
      menuBestEl.textContent = "Mejor puntuaciÃ³n: " + POINTS.best;
    }
    updateBestDisplays();

    let started = false;
    function startGame(){
      if (started) return;
      started = true;
      resetGame();
      playMusic(MUSIC.base);
      lastFrame = performance.now();
      requestAnimationFrame(loop);
    }

    btnStart.addEventListener('click', ()=>{
      menuPanel.classList.remove('show');
      showCountdown(()=>{ startGame(); });
    });

    // pointer bindings already added

    // ================= LOADER rotation =================
    (function rotateLoaderImage(){
      const imgs = ASSETS.loaders;
      const pick = imgs[Math.floor(Math.random()*imgs.length)];
      loaderImg.src = pick;
    })();

    // Hide loader after assets loaded
    loadAll().then(()=>{
      // ensure currentBg set
      currentBg = IMG.bg.calc || null;
      initClouds();
      // remove loader
      setTimeout(()=>{ loader.style.display = 'none'; }, 600);
      // show menu (menu panel already visible)
    }).catch(err=>{
      console.error("Error cargando assets:", err);
      loader.style.display = 'none';
    });

    // ================= INPUT small improvements =================
    // make canvas pointerdown more responsive (already implemented). Also keyboard support for testing:
    window.addEventListener('keydown', (e)=>{
      if (e.code === 'Space') { if (!isDown){ isDown = true; } }
      if (e.code === 'KeyR') { if (panel.classList.contains('show')) btnRestart.click(); }
    });
    window.addEventListener('keyup', (e)=>{
      if (e.code === 'Space') { if (isDown){ isDown = false; justReleased = true; } }
    });

    // ================= STARTUP default =================
    // set initial music icon
    btnMusic.textContent = musicEnabled ? "ðŸ”Š" : "ðŸ”‡";

    // expose a simple test-mode helper (console)
    window.__ASTUTOERIZO = {
      resetGame,
      startGame,
      onGameOver,
      setTestPoints(n){
        POINTS.total = n;
        scoreEl.textContent = "Puntos: " + POINTS.total;
      },
      TEST_MODE
    };

    // small housekeeping: when leaving page, pause music
    window.addEventListener('pagehide', ()=>{ stopAllMusic(); });

    // autoplay note: try to resume audio context on first user interaction if needed (handled on pointerdown)
  })();
  </script>
</body>
</html>
